---
title: "Flipbooks with {flipbookr}"
author: "Gina Reynolds"
date: "7/22/2020"
output: html_document
---


```{r, echo = F}
knitr::opts_chunk$set(echo = F)
```


Have you heard of code-movies or "flipbooks"? Maybe not? I'm happy to tell you about this mode of communication and the {flipbookr} package that can help you build them.  The idea of flipbooks is to show you details of getting from point A to point B using data manipulation, analysis, or visualization pipelines.   When using R markdown or Jupytr notebooks, we usually only see the input and output for a pipeline of steps.   Having the inputs and outputs nearby is really helpful in communicating the big picture of what is being accomplished with a chunk of code.   

But newcomers and even seasoned practitioners might have trouble figuring out what individual steps in a pipeline accomplish.   This is where flipbooks come in! They seek to illuminate *what's going on in the in-between steps.*   Flipbooks do this by showing in-between outputs as the code is built up.   

The 'flipbook' or code-movie technique is one that you see from time to time in coding presentations.  Presenters know that showing a code pipeline as it is built helps audiences digest workflows.  So they choreograph a set of slides to show the build!

### Getting to flipbook faster

While code-movies deliver helpful insight to consumers, putting together this code-movie experience can be time consuming for creators. There's a lot of copy-paste that has to happen to create the right partial code sequence -- and you can mix yourself up in trying to coordinate it (I've been there!).

The package [{flipbookr}](https://github.com/EvaMaeRey/flipbookr)'s goal is to help create these easy-to-follow-along-with step-by-step experiences.     

### Under the hood

So what is {flipbookr} doing? First, it parses entire code chunks as inputs. Then, it identifies good break points for showing in-between output. Given the pause points, it then constructs partial builds of code. Finally these partial builds are delivered alongside associated outputs on slide show tool ([xaringan](https://github.com/yihui/xaringan)!). This gives you the movie-like experience. You can more directly relate a specific function to the change in output it results in.   There is so much cool decision making packed in code pipelines --- the {flipbookr} project is about appreciating those decisions and bringing them into the spotlight!

### Taking Flipbookr for a spin

One way to get started with flipbookr is using this [Easy Flipbook Recipes](https://evamaerey.github.io/flipbooks/flipbook_recipes#1) guide. Or, you can use "A minimal flipbook" template that comes with the package.  Using R Studio, 

install flipbookr: `remotes::install_github("EvaMaeRey/flipbookr")`.  
Then: File -> New File -> Rmarkdown -> A Minimal Flipbook


### Examples and experiences

Not convinced? It might also be useful to hear about the experience of designing flipbooks from relative newcomers perspective.  Four of my students built flipbooks here.  They offer some comments on the experience of writing them.  

<!-- So writing code for to create flipbooks is a little different than writing code only to accomplish a task.  It is more like choreographing an experience.  As much as possible, the creators should try to write the code so that their is feedback as code is revealed.    -->




> Conner's experience:

```{r}
xaringanExtra::embed_xaringan("AUS_InteractMap/AUS_tmap.html")
```



> Britt's experience:

```{r}
xaringanExtra::embed_xaringan("magick/magick.html")
```

> Luca's experience:


```{r}
xaringanExtra::embed_xaringan("unemployment/unemployment.html")
```

Rachel's experience:

```{r}
xaringanExtra::embed_xaringan("Idaho Mapping/Idaho_mapping.html")
```


> *The process of producing a flipbook pushed me to think differently about both data wrangling and data visualization. It required me to be more deliberate in how I wrote and ordered my code... - Rachel*


### Flipbookr heroes

This project ...

<!-- It required me to be more deliberate in how I wrote and ordered my code, and it revealed redundancies and other inefficiencies in my script. The process also deepened my understanding of the commands that I employed by allowing me to see the output of each individual line of code. -->